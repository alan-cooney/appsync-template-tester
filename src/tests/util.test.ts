import {
  escapeJavaScript,
  qr,
  quiet,
  urlEncode,
  urlDecode,
  base64Encode,
  base64Decode,
  parseJson,
  toJson,
  autoId,
  unauthorized,
  error,
  appendError,
  validate,
  isNull,
  isNullOrEmpty,
  isNullOrBlank,
  defaultIfNull,
  defaultIfNullOrEmpty,
  defaultIfNullOrBlank,
  isString,
  isNumber,
  isBoolean,
  isList,
  isMap,
  typeOf,
  matches,
} from "../util";

/**
 * Tests are predominantly generated by running these objects through an AppSync resolver tester (on a real resolver)
 */

test("qr returns blank string", () => {
  const res = qr();
  expect(res).toBe("");
});

test("quiet returns blank string", () => {
  const res = quiet();
  expect(res).toBe("");
});

test("escapeJavaScrip escapes JavaScript (not necessarily in exactly the same way as AppSync)", () => {
  const str = "' ? ! `  /";
  const res = escapeJavaScript(str);
  expect(res).not.toBe(str);
});

test("urlEncode encodes URLs in the same way as AppSync", () => {
  const str = "/hi?page=1&test=2";
  const expected = "%2Fhi%3Fpage%3D1%26test%3D2";
  const res = urlEncode(str);
  expect(res).toBe(expected);
});

test("urlDecode decodes URLs in the same way as AppSync", () => {
  const str = "%2Fhi%3Fpage%3D1%26test%3D2";
  const expected = "/hi?page=1&test=2";
  const res = urlDecode(str);
  expect(res).toBe(expected);
});

test("base64Encode encodes in the same way as AppSync", () => {
  const str = "hello()";
  const expected = "aGVsbG8oKQ==";
  const res = base64Encode(str);
  expect(res).toBe(expected);
});

test("base64Decode decodes in the same way as AppSync", () => {
  const buffer = "aGVsbG8oKQ==";
  const expected = "hello()";
  const res = base64Decode(buffer);
  expect(res).toBe(expected);
});

test("parseJson parses a JSON string and returns the object", () => {
  const obj = {
    testKey: "testValue",
  };
  const json = JSON.stringify(obj);
  const res = parseJson(json);
  expect(res).toEqual(obj);
});

test("toJson stringifies an object", () => {
  const obj = {
    testKey: "testValue",
  };
  const json = JSON.stringify(obj);
  const res = toJson(obj);
  expect(res).toBe(json);
});

test("toJson stringifies an string", () => {
  const obj = "testValue";
  const json = JSON.stringify(obj);
  const res = toJson(obj);
  expect(res).toBe(json);
});

test("autoId returns a 128-bit ID", () => {
  const res = autoId();
  const expectedFormat = /^[\w\d]{8}-[\w\d]{4}-[\w\d]{4}-[\w\d]{4}-[\w\d]{12}$/;
  expect(res).toMatch(expectedFormat);
});

test("unauthorized", () => {
  expect(() => unauthorized()).toThrow("Unauthorized");
});

describe("error", () => {
  test("throws first string argument if given", () => {
    const testMessage = "errorMessage";
    expect(() => error(testMessage)).toThrow(testMessage);
  });

  test("does nothing with no arguments", () => {
    error();
  });
});

test("appendError does nothing", () => {
  appendError();
});

describe("validate", () => {
  test("false throws an error", () => {
    const testMessage = "errorMessage";
    expect(() => validate(false, testMessage)).toThrow(testMessage);
  });

  test("true returns a blank string", () => {
    const result = validate(true, "errorMessage");
    expect(result).toBe("");
  });
});

describe("isNull", () => {
  test.each([
    [null, true],
    [undefined, true],
    ["", false],
    ["\t", false],
    ["sdfasdf", false],
  ])("isNull(%p) -> %p", (input, expected) => {
    const res = isNull(input);
    expect(res).toBe(expected);
  });
});

describe("isNullOrEmpty", () => {
  test.each([
    [null, true],
    [undefined, true],
    ["", true],
    ["\t", false],
    ["sdfasdf", false],
  ])("isNullOrEmpty(%p) -> %p", (input, expected) => {
    const res = isNullOrEmpty(input);
    expect(res).toBe(expected);
  });
});

describe("isNullOrBlank", () => {
  test.each([
    [null, true],
    [undefined, true],
    ["", true],
    ["\t", true],
    ["sdfasdf", false],
  ])("isNullOrBlank(%p) -> %p", (input, expected) => {
    const res = isNullOrBlank(input);
    expect(res).toBe(expected);
  });
});

describe("defaultIfNull", () => {
  test.each([
    [null, true],
    ["", false],
    ["\t", false],
    ["sdfasdf", false],
  ])("defaultIfNull(%p) -> %p", (obj, expectShowDefault) => {
    const defaultObj = "default";
    const res = defaultIfNull(obj, defaultObj);
    const expected = expectShowDefault ? defaultObj : obj;
    expect(res).toBe(expected);
  });
});

describe("defaultIfNullOrEmpty", () => {
  test.each([
    [null, true],
    ["", true],
    ["\t", false],
    ["sdfasdf", false],
  ])("defaultIfNullOrEmpty(%p) -> %p", (obj, expectShowDefault) => {
    const defaultObj = "default";
    const res = defaultIfNullOrEmpty(obj, defaultObj);
    const expected = expectShowDefault ? defaultObj : obj;
    expect(res).toBe(expected);
  });
});

describe("defaultIfNullOrBlank", () => {
  test.each([
    [null, true],
    ["", true],
    ["\t", true],
    ["sdfasdf", false],
  ])("defaultIfNullOrBlank(%p) -> %p", (obj, expectShowDefault) => {
    const defaultObj = "default";
    const res = defaultIfNullOrBlank(obj, defaultObj);
    const expected = expectShowDefault ? defaultObj : obj;
    expect(res).toBe(expected);
  });
});

describe("type checking", () => {
  test.each`
    value    | isStr    | isNum    | isBool   | isLst    | isMp     | typ
    ${null}  | ${false} | ${false} | ${false} | ${false} | ${false} | ${"Null"}
    ${"abc"} | ${true}  | ${false} | ${false} | ${false} | ${false} | ${"String"}
    ${""}    | ${true}  | ${false} | ${false} | ${false} | ${false} | ${"String"}
    ${1}     | ${false} | ${true}  | ${false} | ${false} | ${false} | ${"Number"}
    ${0}     | ${false} | ${true}  | ${false} | ${false} | ${false} | ${"Number"}
    ${false} | ${false} | ${false} | ${true}  | ${false} | ${false} | ${"Boolean"}
    ${true}  | ${false} | ${false} | ${true}  | ${false} | ${false} | ${"Boolean"}
    ${[]}    | ${false} | ${false} | ${false} | ${true}  | ${false} | ${"List"}
    ${{}}    | ${false} | ${false} | ${false} | ${false} | ${true}  | ${"Map"}
  `(
    "the type for value %p is detected correctly",
    ({ value, isStr, isNum, isBool, isLst, isMp, typ }) => {
      expect(isString(value)).toBe(isStr);
      expect(isNumber(value)).toBe(isNum);
      expect(isBoolean(value)).toBe(isBool);
      expect(isList(value)).toBe(isLst);
      expect(isMap(value)).toBe(isMp);
      expect(typeOf(value)).toBe(typ);
    }
  );
});

test("matches", () => {
  const res = matches("^a", "a");
  expect(res).toBeTruthy();
});
